# frozen_string_literal: true

source 'https://rubygems.org'

# gem "rails"

gem 'rubocop', '~> 1.66', require: false

gem 'rubocop-performance', '~> 1.21', require: false

gem 'colorize', '~> 1.1'
GEM
  remote: https://rubygems.org/
  specs:
    ast (2.4.2)
    colorize (1.1.0)
    json (2.7.2)
    language_server-protocol (3.17.0.3)
    parallel (1.26.3)
    parser (3.3.4.2)
      ast (~> 2.4.1)
      racc
    racc (1.8.1)
    rainbow (3.1.1)
    regexp_parser (2.9.2)
    rubocop (1.66.0)
      json (~> 2.3)
      language_server-protocol (>= 3.17.0)
      parallel (~> 1.10)
      parser (>= 3.3.0.2)
      rainbow (>= 2.2.2, < 4.0)
      regexp_parser (>= 2.4, < 3.0)
      rubocop-ast (>= 1.32.1, < 2.0)
      ruby-progressbar (~> 1.7)
      unicode-display_width (>= 2.4.0, < 3.0)
    rubocop-ast (1.32.1)
      parser (>= 3.3.1.0)
    rubocop-performance (1.21.1)
      rubocop (>= 1.48.1, < 2.0)
      rubocop-ast (>= 1.31.1, < 2.0)
    ruby-progressbar (1.13.0)
    unicode-display_width (2.5.0)

PLATFORMS
  ruby
  x86_64-linux

DEPENDENCIES
  colorize (~> 1.1)
  rubocop (~> 1.66)
  rubocop-performance (~> 1.21)

BUNDLED WITH
   2.5.18
# chess
A project to apply my problem solving skills, my knowledge of ruby &amp; data structures
require 'colorize'

require_relative 'pieces/pawn'
require_relative 'pieces/rook'
require_relative 'pieces/king'
require_relative 'pieces/knight'
require_relative 'pieces/queen'
require_relative 'pieces/bishop'

require_relative 'notation'

# Board class handling mostly printing logic
class Board
  include Notation
  attr_accessor :data

  PLAYER_ONE = :white
  PLAYER_TWO = :black
  DARK_CELL = :black
  LIGHT_CELL = :white
  EMPTY_CELL = ' '.freeze
  def initialize
    @data = Array.new(8) { Array.new(8) }
    initialize_player(PLAYER_ONE)
    initialize_player(PLAYER_TWO)
  end

  def print_board
    data.reverse.each_with_index do |rank, index|
      print "#{8 - index} "
      rank.each_with_index do |cell, subindex|
        new_cell = "#{cell&.symbol || EMPTY_CELL} "

        print((index + subindex).even? ? new_cell.colorize(background: LIGHT_CELL) : new_cell.colorize(background: DARK_CELL))
      end
      puts
    end
    puts '  a b c d e f g h'
  end

  def king(color)
    each_piece do |piece|
      return piece if piece.is_a?(King) && piece.color == color
    end
  end

  def piece_move(initial_pos, final_pos)
    initial_row, initial_column = initial_pos
    final_row, final_column = final_pos
    data[final_row][final_column] = data[initial_row][initial_column]
    data[initial_row][initial_column] = nil
    piece_at(*final_pos).coordinates = to_coordinates(*final_pos)
  end

  def piece_at(position, position_opt = nil)
    if position_opt.nil?
      row, column = to_index(position)
    elsif [position, position_opt].all?(Integer) && [position, position_opt].all? { |pos| pos.between?(0, 7) }
      row = position
      column = position_opt
    else
      raise ArgumentError
    end
    data[row][column]
  end

  def each_piece(color = nil, &block)
    if color.nil?
      data.flatten.compact.each(&block)
    else
      pieces = data.flatten.compact.select { |piece| piece.color == color }
      pieces.each(&block)
    end
  end

  private

  def initialize_player(player)
    row = player == PLAYER_ONE ? 0 : 7
    pawn_row = player == PLAYER_ONE ? 1 : 6

    pieces = [Rook, Knight, Bishop, Queen, King, Bishop, Knight, Rook]

    data[row] = pieces.map.with_index { |piece, column| piece.new(player, to_coordinates(row, column)) }
    data[pawn_row] = Array.new(8) { |column| Pawn.new(player, to_coordinates(pawn_row, column)) }
  end
end
require_relative 'board'
require_relative 'notation'
require_relative 'players/human'
require_relative 'players/computer'
class Game
  include Notation

  attr_reader :current_player

  def initialize
    @board = Board.new
    @player = [Human.new, Computer.new]
    @current_player = 0
  end

  def start
    loop do
      @board.print_board
      initial_pos, parsed_notation = play # Now, the current player is the next player
      if initial_pos.nil?
        puts 'Checkmate!'
        return
      end
      final_pos = to_index(parsed_notation[:final_position])
      @board.king(current_player_color).moved = true if @board.piece_at(*initial_pos).is_a? King
      @board.piece_move(initial_pos, final_pos)
    end
  end

  def current_player_color
    (current_player.zero? ? Board::PLAYER_ONE : Board::PLAYER_TWO)
  end

  # returns hash with key as initial position and value as all possible moves
  def next_moves
    all_moves = {}
    @board.data.compact.each do |file|
      file.compact.each do |piece|
        next unless piece.color == current_player_color # To get moves of the current player

        initial_coordinate, moves = piece.next_moves_algebraic(@board)
        all_moves[initial_coordinate] = moves unless moves.empty?
      end
    end
    king = king(current_player)
    all_moves[:long_castle] = 'O-O-O' if king.can_castle_long?
    all_moves[:short_castle] = 'O-O' if king.can_castle_short?
    all_moves
  end

  def play
    moves = next_moves
    return nil if moves.empty?

    possible_moves = moves.values.flatten
    player = @player[current_player]
    player_move = player.play(possible_moves)
    loop do
      break if possible_moves.include? player_move

      puts 'Illegal move, try again...'
      player_move = player.play(moves)
    end
    next_player_turn
    found_value = nil
    moves.each_value { |element| found_value = element if element.include? player_move }
    [to_index(moves.key(found_value)), parse_notation(player_move)]
  end

  # current_player can only have 0 or 1 as values, 0 : player_one, 1 : player_two
  def next_player_turn
    @current_player = (current_player + 1) % 2
  end
end

test = Game.new
test.start
# frozen_string_literal: true

require_relative 'board'

module MoveValidator
  def deep_copy(data)
    Marshal.load(Marshal.dump(data))
  end

  def empty_square?(board, position)
    piece_board = board.piece_at(*position)
    piece_board.nil?
  end

  def enemy_square?(board, position)
    piece_board = board.piece_at(*position)
    !piece_board.nil? && enemy?(piece_board)
  end

  # Checks if there is the given player is in check in current board
  def check?(board, color)
    # We flatten the board since it's an array for array
    board.each_piece.any? do |piece|
      piece.calculate_next_moves(board).any? do |move|
        piece_at_move = board.piece_at(*move)
        piece_at_move.is_a?(King) && piece_at_move.color == color
      end
    end
  end

  def simulate_move(board, initial_pos, final_pos)
    copy_board = deep_copy(board)
    copy_board.piece_move(initial_pos, final_pos)
    copy_board
  end

  # O-O
  def short_castle_blocked?(board, color)
    rank = color == Board::PLAYER_ONE ? 0 : 7
    enemy = color == Board::PLAYER_ONE ? Board::PLAYER_TWO : Board::PLAYER_ONE
    is_hallway_free = board.piece_at?(rank, 5).nil? && board.piece_at?(rank, 6).nil?
    board.each_piece(enemy).any? do |piece|
      piece_moves = piece.next_moves
      piece_moves.include?([rank, 5]) || piece_moves.include?([rank, 6])
    end || !is_hallway_free
  end

  # O-O-O
  def long_castle_blocked?(board, color)
    rank = color == Board::PLAYER_ONE ? 0 : 7
    is_hallway_free = board.piece_at?(rank, 1).nil? && board.piece_at?(rank, 2).nil? && board.piece_at?(rank, 3).nil?
    board.each_piece(enemy).any? do |piece|
      piece_moves = piece.next_moves
      piece_moves.include?([rank, 5]) || piece_moves.include?([rank, 6])
    end || !is_hallway_free
  end
end
# frozen_string_literal: true

# Notation module that contains operations on algebraic notation and indexes
module Notation
  NOTATION = /^(?<piece>(?<_>[KBNQR][a-h]?[1-8]?)|[a-h])?(?:(?<=[a-h])x|x?)(?<final_position>[a-h][1-8])(?<promotion>=?[KBNQR])?(?<check?>[#+])?$/.freeze
  CASTLE_NOTATION = /^O-O(?:-O)?$/.freeze
  COORDINATES = /^[a-h][1-8]$/.freeze
  def to_coordinates(row, column)
    raise ArgumentError unless [row, column].all?(Integer)

    ('a'.ord + column).chr + (row + 1).to_s
  end

  def to_index(coordinates)
    raise ArgumentError unless coordinates.is_a?(String) && correct_coordinates?(coordinates)

    [coordinates[1].to_i - 1, coordinates[0].ord - 'a'.ord]
  end

  def notation_check?(notation)
    raise ArgumentError unless notation.is_a? String

    notation[-1] == '+'
  end

  def correct_index?(index)
    index.all? { |element| element.between?(0, 7) }
  end

  def parse_notation(algebraic)
    raise ArgumentError unless algebraic.is_a? String

    algebraic.match(NOTATION) || algebraic.match(CASTLE_NOTATION)
  end

  def correct_notation?(algebraic)
    raise ArgumentError unless algebraic.is_a? String

    algebraic.match?(NOTATION) || algebraic.match?(CASTLE_NOTATION)
  end

  def coordinates_rank(coordinates)
    raise ArgumentError unless coordinates.is_a?(String) && correct_coordinates?(coordinates)

    coordinates[1]
  end

  def coordinates_file(coordinates)
    raise ArgumentError unless coordinates.is_a?(String) && correct_coordinates?(coordinates)

    coordinates[0]
  end

  def move_to_algebraic(board, piece, move)
    "#{piece.notation}#{print_capture(board, piece, move)}#{to_coordinates(*move)}"
  end

  def correct_coordinates?(coordinates)
    coordinates.match?(COORDINATES)
  end

  private

  def print_capture(board, piece, piece_move)
    return if board.piece_at(*piece_move).nil?

    "#{piece.file if piece.is_a?(Pawn)}x"
  end
end
require_relative 'notation'
require_relative 'move_validator'
require_relative 'board'
class Piece
  include Notation
  include MoveValidator

  attr_reader :color
  attr_accessor :coordinates

  PIECES = { knight: '♞', queen: '♛', king: '♚', rook: '♜', bishop: '♝', pawn: '♟' }.freeze
  def initialize(color, coordinates)
    @color = color
    @coordinates = coordinates # coordinates (e.g: h1 d3 f4)
  end

  def enemy?(piece)
    raise ArgumentError unless piece.is_a? Piece

    color != piece.color
  end

  def rank
    coordinates_rank(coordinates)
  end

  def file
    coordinates_file(coordinates)
  end

  def next_moves_algebraic(board)
    moves = next_moves(board)
    moves = moves.map do |move|
      simulated_board = simulate_move(board, to_index(coordinates), move)
      move_to_algebraic(board, self, move) + (check?(simulated_board, enemy_color) ? '+' : '')
    end
    [coordinates, moves]
  end

  def enemy_color
    color == Board::PLAYER_ONE ? Board::PLAYER_TWO : Board::PLAYER_ONE
  end

  def to_s
    self.class.to_s
  end

  # Method for Queen, Rook, Bishop to inherit due to them having the same logic, to be overridden in other pieces
  def calculate_next_moves(board)
    moves = []
    row, column = to_index(coordinates)
    self.class::MOVES_OFFSETS.each do |move|
      offset_row, offset_column = move
      next_position = [row + offset_row, column + offset_column]
      while correct_index?(next_position) && empty_square?(board, next_position)
        moves << next_position
        offset_row += move.first
        offset_column += move.last
        next_position = [row + offset_row, column + offset_column]
      end
      moves << next_position if correct_index?(next_position) && enemy_square?(board, next_position)
    end
    moves
  end

  def next_moves(board)
    filter_checked_moves(board, calculate_next_moves(board))
  end

  private

  def filter_checked_moves(board, moves)
    moves.reject do |move|
      simulated_board = simulate_move(board, to_index(coordinates), move)
      check?(simulated_board, color)
    end
  end
end
class Player
  def initialize(color)
    @color = color
  end

  def play; end
end
require './lib/notation'
describe Notation do
  include Notation
  describe '#parse_notation' do
    describe 'simple pawn moves' do
      it 'validates e4' do
        expect(parse_notation('e4')).to_not eql nil
      end
      it 'validates d5' do
        expect(parse_notation('d5')).to_not eql nil
      end
      it 'validates a3' do
        expect(parse_notation('a3')).to_not eql nil
      end
      it 'validates h6' do
        expect(parse_notation('h6')).to_not eql nil
      end
    end

    describe 'simple piece moves' do
      it 'validates Nf3' do
        expect(parse_notation('Nf3')).to_not eql nil
      end
      it 'validates Bg5' do
        expect(parse_notation('Bg5')).to_not eql nil
      end
      it 'validates Qd4' do
        expect(parse_notation('Qd4')).to_not eql nil
      end
      it 'validates Ke2' do
        expect(parse_notation('Ke2')).to_not eql nil
      end
      it 'validates Ra4' do
        expect(parse_notation('Ra4')).to_not eql nil
      end
    end
    describe 'check piece moves' do
      it 'validates Nf3+' do
        expect(parse_notation('Nf3+')).to_not eql nil
      end
      it 'validates Bxg5+' do
        expect(parse_notation('Bxg5+')).to_not eql nil
      end
      it 'validates Qh4xd4+' do
        expect(parse_notation('Qh4xd4+')).to_not eql nil
      end
      it 'validates Kxe2+' do
        expect(parse_notation('Kxe2+')).to_not eql nil
      end
      it 'validates Ra4+' do
        expect(parse_notation('Ra4+')).to_not eql nil
      end
    end

    describe 'captures' do
      it 'validates exd5' do
        expect(parse_notation('exd5')).to_not eql nil
      end
      it 'validates Bxf7' do
        expect(parse_notation('Bxf7')).to_not eql nil
      end
      it 'validates Qxd8' do
        expect(parse_notation('Qxd8')).to_not eql nil
      end
      it 'validates Nxe5' do
        expect(parse_notation('Nxe5')).to_not eql nil
      end
    end

    describe 'specific piece disambiguation' do
      it 'validates Nge2' do
        expect(parse_notation('Nge2')).to_not eql nil
      end
      it 'validates R1a3' do
        expect(parse_notation('R1a3')).to_not eql nil
      end
      it 'validates Qh4e1' do
        expect(parse_notation('Qh4e1')).to_not eql nil
      end
    end

    describe 'promotions' do
      it 'validates e8=Q' do
        expect(parse_notation('e8=Q')).to_not eql nil
      end
      it 'validates a1=N' do
        expect(parse_notation('a1=N')).to_not eql nil
      end
      it 'validates h8=R' do
        expect(parse_notation('h8=R')).to_not eql nil
      end
    end

    describe 'captures with promotions' do
      it 'validates exf8=Q' do
        expect(parse_notation('exf8=Q')).to_not eql nil
      end
      it 'validates hxg1=B' do
        expect(parse_notation('hxg1=B')).to_not eql nil
      end
    end

    describe 'invalid moves' do
      it 'invalidates e9' do
        expect(parse_notation('e9')).to eql nil
      end
      it 'invalidates Px' do
        expect(parse_notation('Px')).to eql nil
      end
      it 'invalidates H4' do
        expect(parse_notation('H4')).to eql nil
      end
      it 'invalidates e8=P' do
        expect(parse_notation('e8=P')).to eql nil
      end
      it 'invalidates Ae4' do
        expect(parse_notation('Ae4')).to eql nil
      end
    end
  end
  describe '#to_coordinates' do
    it 'converts row 0, column 0 to "a1"' do
      expect(to_coordinates(0, 0)).to eq('a1')
    end

    it 'converts row 0, column 7 to "h1"' do
      expect(to_coordinates(0, 7)).to eq('h1')
    end

    it 'converts row 7, column 0 to "a8"' do
      expect(to_coordinates(7, 0)).to eq('a8')
    end

    it 'converts row 7, column 7 to "h8"' do
      expect(to_coordinates(7, 7)).to eq('h8')
    end
    it 'converts row 3, column 5 to "f4"' do
      expect(to_coordinates(3, 5)).to eq('f4')
    end
    it 'converts row 1, column 3 to "d2"' do
      expect(to_coordinates(1, 3)).to eq('d2')
    end
  end
end
# This file was generated by the `rspec --init` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# The generated `.rspec` file contains `--require spec_helper` which will cause
# this file to always be loaded, without a need to explicitly require it in any
# files.
#
# Given that it is always loaded, you are encouraged to keep this file as
# light-weight as possible. Requiring heavyweight dependencies from this file
# will add to the boot time of your test suite on EVERY test run, even for an
# individual file that may not need all of that loaded. Instead, consider making
# a separate helper file that requires the additional dependencies and performs
# the additional setup, and require it from the spec files that actually need
# it.
#
# See https://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
RSpec.configure do |config|
  # rspec-expectations config goes here. You can use an alternate
  # assertion/expectation library such as wrong or the stdlib/minitest
  # assertions if you prefer.
  config.expect_with :rspec do |expectations|
    # This option will default to `true` in RSpec 4. It makes the `description`
    # and `failure_message` of custom matchers include text for helper methods
    # defined using `chain`, e.g.:
    #     be_bigger_than(2).and_smaller_than(4).description
    #     # => "be bigger than 2 and smaller than 4"
    # ...rather than:
    #     # => "be bigger than 2"
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  # rspec-mocks config goes here. You can use an alternate test double
  # library (such as bogus or mocha) by changing the `mock_with` option here.
  config.mock_with :rspec do |mocks|
    # Prevents you from mocking or stubbing a method that does not exist on
    # a real object. This is generally recommended, and will default to
    # `true` in RSpec 4.
    mocks.verify_partial_doubles = true
  end

  # This option will default to `:apply_to_host_groups` in RSpec 4 (and will
  # have no way to turn it off -- the option exists only for backwards
  # compatibility in RSpec 3). It causes shared context metadata to be
  # inherited by the metadata hash of host groups and examples, rather than
  # triggering implicit auto-inclusion in groups with matching metadata.
  config.shared_context_metadata_behavior = :apply_to_host_groups

# The settings below are suggested to provide a good initial experience
# with RSpec, but feel free to customize to your heart's content.
=begin
  # This allows you to limit a spec run to individual examples or groups
  # you care about by tagging them with `:focus` metadata. When nothing
  # is tagged with `:focus`, all examples get run. RSpec also provides
  # aliases for `it`, `describe`, and `context` that include `:focus`
  # metadata: `fit`, `fdescribe` and `fcontext`, respectively.
  config.filter_run_when_matching :focus

  # Allows RSpec to persist some state between runs in order to support
  # the `--only-failures` and `--next-failure` CLI options. We recommend
  # you configure your source control system to ignore this file.
  config.example_status_persistence_file_path = "spec/examples.txt"

  # Limits the available syntax to the non-monkey patched syntax that is
  # recommended. For more details, see:
  # https://rspec.info/features/3-12/rspec-core/configuration/zero-monkey-patching-mode/
  config.disable_monkey_patching!

  # This setting enables warnings. It's recommended, but in some cases may
  # be too noisy due to issues in dependencies.
  config.warnings = true

  # Many RSpec users commonly either run the entire suite or an individual
  # file, and it's useful to allow more verbose output when running an
  # individual spec file.
  if config.files_to_run.one?
    # Use the documentation formatter for detailed output,
    # unless a formatter has already been configured
    # (e.g. via a command-line flag).
    config.default_formatter = "doc"
  end

  # Print the 10 slowest examples and example groups at the
  # end of the spec run, to help surface which specs are running
  # particularly slow.
  config.profile_examples = 10

  # Run specs in random order to surface order dependencies. If you find an
  # order dependency and want to debug it, you can fix the order by providing
  # the seed, which is printed after each run.
  #     --seed 1234
  config.order = :random

  # Seed global randomization in this process using the `--seed` CLI option.
  # Setting this allows you to use `--seed` to deterministically reproduce
  # test failures related to randomization by passing the same `--seed` value
  # as the one that triggered the failure.
  Kernel.srand config.seed
=end
end
require_relative '../piece'

class Bishop < Piece
  attr_reader :symbol, :notation

  MOVES_OFFSETS = [1, -1].repeated_permutation(2).to_a
  def initialize(color, coordinates)
    super
    @symbol = Piece::PIECES[:bishop].colorize(color)
    @notation = 'B'
  end
end
require_relative '../piece'
class King < Piece
  attr_reader :symbol, :notation
  attr_writer :moved, :checked

  MOVES_OFFSETS = [1, -1, 0].repeated_permutation(2).to_a[0..-2] # Removes [0,0]
  MOVES_OFFSETS.pop
  def initialize(color, coordinates)
    super
    @symbol = Piece::PIECES[:king].colorize(color)
    @notation = 'K'
    @moved = false
    @checked = false
  end

  def moved?
    @has_moved
  end

  def checked?
    @checked
  end

  def calculate_next_moves(board)
    moves = []
    row, column = to_index(coordinates)
    MOVES_OFFSETS.each do |offset|
      final_position = [row + offset.first, column + offset.last]
      moves << final_position if correct_index?(final_position) && (empty_square?(board,
                                                                                  final_position) || enemy_square?(
                                                                                    board, final_position
                                                                                  ))
    end
    moves
  end

  def can_castle_long?(board)
    !checked? && !moved? && long_castle_blocked?(board, color)
  end

  def can_castle_short?(board)
    !checked? && !moved? && short_castle_blocked?(board, color)
  end
end
# frozen_string_literal: true

require_relative '../piece'
# Knight class for the knight piece
class Knight < Piece
  attr_reader :symbol, :notation

  MOVES_OFFSETS = [1, -1].product([2, -2]) + [2, -2].product([1, -1])
  def initialize(color, coordinates)
    super
    @symbol = Piece::PIECES[:knight].colorize(color)
    @notation = 'N'
  end

  # Calculate possible next moves in current position
  def calculate_next_moves(board)
    moves = []
    row, column = to_index(coordinates)
    MOVES_OFFSETS.each do |offset|
      final_position = [row + offset.first, column + offset.last]
      moves << final_position if correct_index?(final_position) && (empty_square?(board,
                                                                                  final_position) || enemy_square?(
                                                                                    board, final_position
                                                                                  ))
    end
    moves
  end
end
require_relative '../piece'

class Pawn < Piece
  attr_reader :symbol, :notation
  attr_accessor :en_passant

  MOVE_OFFSETS_ONE = 1
  MOVE_OFFSETS_TWO = -1
  RANK = [nil, '2', '7'].freeze
  def initialize(color, coordinates)
    super
    @symbol = Piece::PIECES[:pawn].colorize(color)
    @notation = ''
    @en_passant = false
  end

  def calculate_next_moves(board)
    moves = []
    row, column = to_index(coordinates)
    offset = (color == Board::PLAYER_ONE ? MOVE_OFFSETS_ONE : MOVE_OFFSETS_TWO)
    final_position = [row + offset, column]
    moves << final_position if correct_index?(final_position) && empty_square?(board, final_position)
    final_position = [row + (offset * 2), column]
    moves << final_position if rank == RANK[offset] && empty_square?(board, final_position)
    moves + capture_moves(board)
  end

  def capture_moves(board)
    moves = []
    row, column = to_index(coordinates)
    offset = (color == Board::PLAYER_ONE ? MOVE_OFFSETS_ONE : MOVE_OFFSETS_TWO)
    [column + offset, column - offset].each do |column_offset|
      final_position = [row + offset, column_offset]
      moves << final_position if correct_index?(final_position) && enemy_square?(board, final_position)
    end
    moves
  end
end
require_relative '../piece'
require_relative 'bishop'
require_relative 'rook'
class Queen < Piece
  attr_reader :symbol, :notation

  MOVES_OFFSETS = Bishop::MOVES_OFFSETS + Rook::MOVES_OFFSETS
  def initialize(color, coordinates)
    super
    @symbol = Piece::PIECES[:queen].colorize(color)
    @notation = 'Q'
  end
end
require_relative '../piece'

class Rook < Piece
  attr_reader :symbol, :notation

  MOVES_OFFSETS = [[0, 1], [0, -1], [1, 0], [-1, 0]].freeze
  def initialize(color, position)
    super
    @symbol = Piece::PIECES[:rook].colorize(color)
    @notation = 'R'
  end
end
require_relative '../player'

class Computer
  def play(moves)
    moves.sample
  end
end
require_relative '../player'
require_relative '../notation'

class Human
  include Notation
  def play(possible_moves)
    print_possible_moves(possible_moves)
    loop do
      user_move = gets.chomp
      return user_move if correct_notation?(user_move)

      puts 'Incorrect algebraic format, try again...'
    end
  end

  private

  def print_possible_moves(possible_moves)
    puts 'Possible moves :'
    possible_moves.each do |piece_move|
      print "#{piece_move} "
    end
    puts
  end
end
